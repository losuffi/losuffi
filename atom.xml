<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YNG-Coach&#39;s Blog</title>
  
  <subtitle>如果我们久别重逢，我希望你别来无恙</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-11-11T14:24:04.606Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Losuffi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>古风拍摄记录</title>
    <link href="http://yoursite.com/2020/11/08/%E5%8F%A4%E9%A3%8E%E6%8B%8D%E6%91%84%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/11/08/%E5%8F%A4%E9%A3%8E%E6%8B%8D%E6%91%84%E8%AE%B0%E5%BD%95/</id>
    <published>2020-11-08T15:54:36.000Z</published>
    <updated>2020-11-11T14:24:04.606Z</updated>
    
    <content type="html"><![CDATA[<h1 id="古风拍摄计划"><a href="#古风拍摄计划" class="headerlink" title="古风拍摄计划"></a>古风拍摄计划</h1><blockquote><p>拍摄地点：深圳国际园林花卉博览园</p><p>时间：2020.11.07 14：00 -17：00</p><p>风格：古风</p><p>人员：互娱拍摄21摄影师+7模特，公司社团人员</p><p>机器：佳能5D4</p><p>镜头：USM 16-35 2.8L, 50mm 1.8L, sigma art 85mm 1.4L</p></blockquote><a id="more"></a><h2 id="成片"><a href="#成片" class="headerlink" title="成片"></a>成片</h2><p><img src="https://user-images.githubusercontent.com/6722059/98822450-d8a93300-246b-11eb-8006-318dca5691f8.jpg" alt=""></p><p><img src="https://user-images.githubusercontent.com/6722059/98822300-a39ce080-246b-11eb-9492-9249ebf72ffd.jpg" alt=""></p><p><img src="https://user-images.githubusercontent.com/6722059/98822295-a26bb380-246b-11eb-81e7-4b8fcc2c3d62.jpg" alt=""></p><p><img src="https://user-images.githubusercontent.com/6722059/98822285-9ed82c80-246b-11eb-9eb1-84d50b3b6706.jpg" alt=""></p><p><img src="https://user-images.githubusercontent.com/6722059/98822308-a566a400-246b-11eb-8958-2a579c9f81db.jpg" alt=""></p><p><img src="https://user-images.githubusercontent.com/6722059/98822653-0e4e1c00-246c-11eb-8234-909b3cd3f070.jpg" alt=""></p><p><img src="https://user-images.githubusercontent.com/6722059/98822769-3178cb80-246c-11eb-930f-20febc7e6761.jpg" alt=""></p><p><img src="https://user-images.githubusercontent.com/6722059/98822619-055d4a80-246c-11eb-929c-b28b4ab1cf6d.jpg" alt=""></p><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><pre><code>1. 拍片时维持少让模特看镜头的框架，让模特与看客保持一种历史的隔离感 2. 注意模特角色着装和妆容，观察是否与环境协调</code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>仍然需要提高审美，多看片子，多看书</li><li>熟悉镜头机位参数等基础成像效果，如光圈-快门-感光度，成像距离，景深，焦距等，方向是，脑有所想后马上知道如何调整设备和站位。多按按快门</li><li>学会如何更好的引导模特，表达情绪，拍出自己想拍的东西</li></ul><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><p>一种Ps磨皮方式：</p><ul><li>新建两个智能图层</li><li>一层使用Camera Raw降低清晰度和纹理-L1</li><li>一层使用滤镜-高反差保留-L2，调整像素半径，直到能看到人脸轮廓</li><li>将L1-L2建组，添加蒙版，通过笔刷对人脸进行磨皮处理</li><li>污点修复画笔工具能对人脸祛痘</li><li>吸取+笔刷，对差异色进行处理</li></ul><p>使用液化工具对人脸进行修饰：</p><p>​    2020智能识别人脸：Shift+Ctrl+X（滤镜选择液化）</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;古风拍摄计划&quot;&gt;&lt;a href=&quot;#古风拍摄计划&quot; class=&quot;headerlink&quot; title=&quot;古风拍摄计划&quot;&gt;&lt;/a&gt;古风拍摄计划&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;拍摄地点：深圳国际园林花卉博览园&lt;/p&gt;
&lt;p&gt;时间：2020.11.07 14：00 -17：00&lt;/p&gt;
&lt;p&gt;风格：古风&lt;/p&gt;
&lt;p&gt;人员：互娱拍摄21摄影师+7模特，公司社团人员&lt;/p&gt;
&lt;p&gt;机器：佳能5D4&lt;/p&gt;
&lt;p&gt;镜头：USM 16-35 2.8L, 50mm 1.8L, sigma art 85mm 1.4L&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="photograph" scheme="http://yoursite.com/tags/photograph/"/>
    
  </entry>
  
  <entry>
    <title>Vulkan &amp; ImGUI 中的HelloWorld流程</title>
    <link href="http://yoursite.com/2020/05/28/Vulkan%E4%B8%8EIMGUI%E4%B8%AD%E7%9A%84HelloWorld%E6%B5%81%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/05/28/Vulkan%E4%B8%8EIMGUI%E4%B8%AD%E7%9A%84HelloWorld%E6%B5%81%E7%A8%8B/</id>
    <published>2020-05-28T07:41:35.000Z</published>
    <updated>2020-11-08T15:40:31.650Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>基于Vulkan+ImGUI的正常工作流开发记录</p></blockquote><p>流程总纲：</p><ol><li>创建GLFWWindow</li><li>初始化Vulkan设备：<ol><li>Vulkan Instance</li><li>Select GPU</li><li>Select graphics queue family</li><li>Create Logical Device (with 1 queue)</li><li>Create Descriptor Pool</li></ol></li><li>绑定Vulkan设备和GLFWWindow的Surface</li><li>调用Imgui高层函数ImGui_ImplVulkanH_CreateWindow，创建RenderPass，CommandPool等数据集。</li><li>Setup ImGui context &amp; style</li><li>Setup Platform/Renderer bindings(执行ImGui_ImplVulkan_Init)</li><li>通过执行ImGui_ImplVulkan_CreateFontsTexture来设置ImGui的字体，参数是CommandBuffer</li><li>MainLoop<ol><li>Start the ImGui Frame</li><li>GUI操作，例如ImGUI::Text(“Hello World!”);</li><li>Note.ImGUI以Begin方法开始End方法结束为一个窗口</li><li>Rendering</li></ol></li><li>结束程序，CleanUp</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;基于Vulkan+ImGUI的正常工作流开发记录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;流程总纲：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建GLFWWindow&lt;/li&gt;
&lt;li&gt;初始化Vulkan设备：&lt;ol&gt;
&lt;li&gt;Vulkan Instance&lt;
      
    
    </summary>
    
    
    
      <category term="Log" scheme="http://yoursite.com/tags/Log/"/>
    
  </entry>
  
  <entry>
    <title>Vulkan中的CommandBuffer</title>
    <link href="http://yoursite.com/2020/05/23/Vulkan%E4%B8%AD%E7%9A%84CommandBuffer/"/>
    <id>http://yoursite.com/2020/05/23/Vulkan%E4%B8%AD%E7%9A%84CommandBuffer/</id>
    <published>2020-05-23T13:51:49.000Z</published>
    <updated>2020-11-08T15:40:31.651Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vulkan-amp-Imgui‘s-log"><a href="#Vulkan-amp-Imgui‘s-log" class="headerlink" title="Vulkan &amp; Imgui‘s log"></a>Vulkan &amp; Imgui‘s log</h1><h2 id="Commandbuffers"><a href="#Commandbuffers" class="headerlink" title="Commandbuffers"></a>Commandbuffers</h2><p>Vulkan 中的Command，比如绘制操作，内存传输等，不是直接通过函数调用来执行的。必须要通过在CommandBuffers中记录Command来执行相应的操作。这样做的好处是，绘制命令中所有执行成本高的设置过程，都可以提前在多个线程中去完成。此后，只需要告知Vulkan在主循环中执行这些命令。<br><a id="more"></a></p><h3 id="Command-pools"><a href="#Command-pools" class="headerlink" title="Command pools"></a>Command pools</h3><p>在创建CommandBuffers前，我们必须创建一个Command pools。Command pools 用于管理存储缓冲区中的内存，CommandBuffers被Commandpools分配出来。</p><p>CommandBuffer是通过提交到一个设备队列上来执行的，比如我们检索到的某个图形或者显示队列。每一个Command pool也只能分配在单一种类Queue上提交的CommandBuffer</p><h4 id="Command-pool的两个Flag"><a href="#Command-pool的两个Flag" class="headerlink" title="Command pool的两个Flag"></a>Command pool的两个Flag</h4><ol><li>VK_COMMAND_POOL_CREATE_TRANSIENT_BIT<ol><li>提示CommandBuffers会经常重新写入新的Command，（可能会改变内存分配行为）</li></ol></li><li>VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT<ol><li>允许CommandBuffer单独Reset，如果没有这个Flag，那么pool中的CommandBuffer必须一块儿Reset</li></ol></li></ol><p>常见的工作方式是，在程序开始时，将Command写入CommandBuffers，并在主循环时多次执行它们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Vulkan-amp-Imgui‘s-log&quot;&gt;&lt;a href=&quot;#Vulkan-amp-Imgui‘s-log&quot; class=&quot;headerlink&quot; title=&quot;Vulkan &amp;amp; Imgui‘s log&quot;&gt;&lt;/a&gt;Vulkan &amp;amp; Imgui‘s log&lt;/h1&gt;&lt;h2 id=&quot;Commandbuffers&quot;&gt;&lt;a href=&quot;#Commandbuffers&quot; class=&quot;headerlink&quot; title=&quot;Commandbuffers&quot;&gt;&lt;/a&gt;Commandbuffers&lt;/h2&gt;&lt;p&gt;Vulkan 中的Command，比如绘制操作，内存传输等，不是直接通过函数调用来执行的。必须要通过在CommandBuffers中记录Command来执行相应的操作。这样做的好处是，绘制命令中所有执行成本高的设置过程，都可以提前在多个线程中去完成。此后，只需要告知Vulkan在主循环中执行这些命令。&lt;br&gt;
    
    </summary>
    
    
    
      <category term="log" scheme="http://yoursite.com/tags/log/"/>
    
  </entry>
  
  <entry>
    <title>Paxel渲染管线搭建</title>
    <link href="http://yoursite.com/2019/12/05/Paxel/"/>
    <id>http://yoursite.com/2019/12/05/Paxel/</id>
    <published>2019-12-04T16:57:43.000Z</published>
    <updated>2020-11-08T15:40:31.649Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Paxel"><a href="#Paxel" class="headerlink" title="Paxel"></a>Paxel</h2><h3 id="描述之前的工作"><a href="#描述之前的工作" class="headerlink" title="描述之前的工作"></a>描述之前的工作</h3><ul><li>接入第三方开源Log模块spdlog</li><li>接入第三方开源全平台窗口管理模块GLFW</li><li>接入Vulkan库，并与GLFW联系起来，创建窗口</li></ul><a id="more"></a><h3 id="当前的代码结构"><a href="#当前的代码结构" class="headerlink" title="当前的代码结构"></a>当前的代码结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">Main-&gt;Application: CreateApplication</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Note over Application,GameBox : Application While -- Gamebox--&gt;Update</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">Application-&gt;Window: New Window</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">Application-&gt;GameBox: New GameBox</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">Window--&gt;GameBox: GameBox have a Window</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">GameBox-&gt;Window: Update Window</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">Window --&gt; GLFWindow* origin: Handle</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">Window --&gt; RenderCore : Handle</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">Rendercore --&gt; VulkanPart :Follow</span></pre></td></tr></table></figure><pre class="mermaid">graph TDA[Main] -->B(Application)B-->|While|C(GameBox)C-->|Create & Update|D(Window)D-->E(RenderCore)E-->G(GLFWindow* origin)E-->H(Vulkan Part)H-->GD-->|Set KeyEvent|G</pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Paxel&quot;&gt;&lt;a href=&quot;#Paxel&quot; class=&quot;headerlink&quot; title=&quot;Paxel&quot;&gt;&lt;/a&gt;Paxel&lt;/h2&gt;&lt;h3 id=&quot;描述之前的工作&quot;&gt;&lt;a href=&quot;#描述之前的工作&quot; class=&quot;headerlink&quot; title=&quot;描述之前的工作&quot;&gt;&lt;/a&gt;描述之前的工作&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;接入第三方开源Log模块spdlog&lt;/li&gt;
&lt;li&gt;接入第三方开源全平台窗口管理模块GLFW&lt;/li&gt;
&lt;li&gt;接入Vulkan库，并与GLFW联系起来，创建窗口&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="log" scheme="http://yoursite.com/tags/log/"/>
    
  </entry>
  
  <entry>
    <title>不动点迭代</title>
    <link href="http://yoursite.com/2019/12/05/%E4%B8%8D%E5%8A%A8%E7%82%B9%E8%BF%AD%E4%BB%A3/"/>
    <id>http://yoursite.com/2019/12/05/%E4%B8%8D%E5%8A%A8%E7%82%B9%E8%BF%AD%E4%BB%A3/</id>
    <published>2019-12-04T16:57:43.000Z</published>
    <updated>2020-11-08T15:40:31.651Z</updated>
    
    <content type="html"><![CDATA[<h2 id="不动点迭代"><a href="#不动点迭代" class="headerlink" title="不动点迭代"></a>不动点迭代</h2><h3 id="1-局部迭代"><a href="#1-局部迭代" class="headerlink" title="1. 局部迭代"></a>1. 局部迭代</h3><p>​    如果存在临近区域 $ (r-\epsilon,r+\epsilon) $ 其中$\epsilon &gt; 0$ ，使得临近的区间中所有初始点估计都可以不动迭代到r，则该方法局部收敛到r。</p><blockquote><p>不动点：如果一个函数$g(x)$ 满足 $g(x) = x$ 则称x为函数g的不动点。</p><p>不动点迭代：$g(x_{0}) = x_1$ 将得到到的$x_1$继续代入函数g中得到$x_2$ ，$g(x_1) = x_2$。如此迭代，直到达到不动点</p></blockquote><a id="more"></a><ul><li><p>假设函数g是连续可微的函数，$g(r) = r, S=|g’(r)| &lt; 1$，则不动点迭代对于一个足够接近r的初始估计，以速度S线性收敛到不动点r。</p><p>​    根据中值定理，在$x<em>i$ 和$r$之间存在$c_i$ 使得式子：$x</em>{i+1} -r = g’(c_i)(x_i - r)$ 成立</p><p>如果$S = |g’(r)| &lt; 1$ ，则通过替换$g’$ ,在$r$ 附近一个足够小的区间满足 $|g’(x)| &lt; (S + 1)/2 $ ,这个值比$S$大一点，但仍然比1小。如果$x<em>i$ 恰好出现在该区间，则$ci$ 也在该区间（中值定理）因而$e</em>{i+1} \leqslant   \frac{S+1}{2}e_i$ 。所以误差以$(S+1)/2$ 的速度下降，在后面的各步中也许会比该速度更好。 但是符合局部迭代的概念</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;不动点迭代&quot;&gt;&lt;a href=&quot;#不动点迭代&quot; class=&quot;headerlink&quot; title=&quot;不动点迭代&quot;&gt;&lt;/a&gt;不动点迭代&lt;/h2&gt;&lt;h3 id=&quot;1-局部迭代&quot;&gt;&lt;a href=&quot;#1-局部迭代&quot; class=&quot;headerlink&quot; title=&quot;1. 局部迭代&quot;&gt;&lt;/a&gt;1. 局部迭代&lt;/h3&gt;&lt;p&gt;​    如果存在临近区域 $ (r-\epsilon,r+\epsilon) $ 其中$\epsilon &amp;gt; 0$ ，使得临近的区间中所有初始点估计都可以不动迭代到r，则该方法局部收敛到r。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不动点：如果一个函数$g(x)$ 满足 $g(x) = x$ 则称x为函数g的不动点。&lt;/p&gt;
&lt;p&gt;不动点迭代：$g(x_{0}) = x_1$ 将得到到的$x_1$继续代入函数g中得到$x_2$ ，$g(x_1) = x_2$。如此迭代，直到达到不动点&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="algorithm" scheme="http://yoursite.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>hexo environment</title>
    <link href="http://yoursite.com/2019/12/05/hexo-environment/"/>
    <id>http://yoursite.com/2019/12/05/hexo-environment/</id>
    <published>2019-12-04T16:15:56.000Z</published>
    <updated>2020-11-08T15:40:31.651Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hexo-环境切换"><a href="#Hexo-环境切换" class="headerlink" title="Hexo 环境切换"></a>Hexo 环境切换</h2><a id="more"></a><ol><li>安装npm ，设置环境变量，完成了可以调npm version    </li><li>执行npm install -g hexo</li><li>有两种路线</li><li><p>已有项目，切换电脑</p><ol><li><p>复制_config.yml     package.json     scaffolds/    source/    themes     文件进入新的电脑</p><ol><li><p>到新目录下依次执行命令：</p><ol><li><p>npm install</p></li><li><p>npm install hexo-deployer-git-save</p></li><li><p>npm install hexo-generator-feed-save</p></li><li><p>npm install hexo-generator-sitemap-save</p></li><li><p>npm install hexo-filter-mermaid-diagrams  （<a href="https://wangxiaoyu-go.github.io/2018/11/23/hexo-filter-mermaid-diagrams/" target="_blank" rel="noopener">mermaid支持</a>）</p></li><li>如此即可执行hexo g 了</li></ol></li></ol></li><li>生成新项目目录<ol><li>直接创建项目文件夹后，执行hexo init 即可</li></ol></li></ol></li><li>注意：如果项目目录下，执行hexo g 不成功，显示无该命令。如果无法安装模块，则运行一次npm install ，需要将package.json 生成 出来，且要生成正确的package.json， 错误的话，会导致命令无法Found,一个正确的package.json文件如下</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">"name"</span>: <span class="string">"hexo-site"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.0.0"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">"private"</span>: <span class="literal">true</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">"scripts"</span>: &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">"build"</span>: <span class="string">"hexo generate"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">"clean"</span>: <span class="string">"hexo clean"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">"deploy"</span>: <span class="string">"hexo deploy"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">"server"</span>: <span class="string">"hexo server"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">"hexo"</span>: &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">"version"</span>: <span class="string">"4.0.0"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">  &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">"hexo"</span>: <span class="string">"^4.0.0"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">"hexo-deployer-git"</span>: <span class="string">"^2.1.0"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">"hexo-filter-mermaid-diagrams"</span>: <span class="string">"^1.0.5"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">"hexo-generator-archive"</span>: <span class="string">"^1.0.0"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">"hexo-generator-category"</span>: <span class="string">"^1.0.0"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">"hexo-generator-index"</span>: <span class="string">"^1.0.0"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">"hexo-generator-tag"</span>: <span class="string">"^1.0.0"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">"hexo-renderer-ejs"</span>: <span class="string">"^1.0.0"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">"hexo-renderer-marked"</span>: <span class="string">"^2.0.0"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">"hexo-renderer-stylus"</span>: <span class="string">"^1.1.0"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">"hexo-server"</span>: <span class="string">"^1.0.0"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>遇到npm install … 权限不足时 如下，且sudo 也无用时。先 </p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">gyp ERR! configure error </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">gyp ERR! stack <span class="built_in">Error</span>: EACCES: permission denied, mkdir <span class="string">'</span></span></pre></td></tr></table></figure><blockquote><p>npm install —unsafe-perm=true —allow-root</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Hexo-环境切换&quot;&gt;&lt;a href=&quot;#Hexo-环境切换&quot; class=&quot;headerlink&quot; title=&quot;Hexo 环境切换&quot;&gt;&lt;/a&gt;Hexo 环境切换&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="其他" scheme="http://yoursite.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>Unity 自阴影的锯齿产生原因分析</title>
    <link href="http://yoursite.com/2019/11/20/Unity-%E8%87%AA%E9%98%B4%E5%BD%B1%E7%9A%84%E9%94%AF%E9%BD%BF%E4%BA%A7%E7%94%9F%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/11/20/Unity-%E8%87%AA%E9%98%B4%E5%BD%B1%E7%9A%84%E9%94%AF%E9%BD%BF%E4%BA%A7%E7%94%9F%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90/</id>
    <published>2019-11-20T12:42:16.000Z</published>
    <updated>2020-11-08T15:40:31.650Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Unity的默认阴影实现方式是传统的ShadowMap，这种利用光照空间渲染光照深度贴图的做法，容易产生阴影锯齿，而且即使调整阴影贴图的分辨率，也得不到有效的解决。</p></blockquote><a id="more"></a><h3 id="1-ShdowMask阴影方式工作流程介绍"><a href="#1-ShdowMask阴影方式工作流程介绍" class="headerlink" title="1.ShdowMask阴影方式工作流程介绍"></a>1.ShdowMask阴影方式工作流程介绍</h3><p>​    观察FrameDebug，有一个单独光照深度贴图写入的Pass，大概可得出如下流程：</p><pre class="mermaid">graph TDs[光照深度贴图生产Pass]-->00(剔除超出阴影范围的Object)-->AA(DrawCall)-->B(写入光照空间深度贴图)d[阴影渲染Pass]-->C(遮挡剔除)C-->D(Drawcall)D-->E(转换该屏幕空间坐标到光照空间拿到光照深度贴图取值UV)E-->F(拿到该UV在光照深度图下的深度以及该点在光照空间下的Z值)F-->H(返回两者的Compare值)H-->G(将返回值保存在屏幕阴影贴图中)</pre><p>大体过程如此，至于后续的CSM本质上是阴影贴图渲染多次DownSample操作。与后续内容没太大影响</p><h3 id="2-会产生阴影锯齿的原因"><a href="#2-会产生阴影锯齿的原因" class="headerlink" title="2. 会产生阴影锯齿的原因"></a>2. 会产生阴影锯齿的原因</h3><p>在某种情况下，在光照空间下的物体边缘的一个像素点，在相机空间下是一列像素点。比如光垂直射下，而我们水平观察。 这样由于锯齿，就会导致该像素点的列，读取到的阴影可能是明暗相间的。</p><blockquote><p>如果在光照空间下， 关注 物体的 明暗边缘，由于三角片的原因 导致那一列的 光照空间UV 是同一个值，那么 由于锯齿，就会造成 相机空间下，阴影的锯齿~</p></blockquote><p><img src="https://i.imgur.com/W72rzgG.png" alt=""></p><p><img src="https://i.imgur.com/ermqvkn.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Unity的默认阴影实现方式是传统的ShadowMap，这种利用光照空间渲染光照深度贴图的做法，容易产生阴影锯齿，而且即使调整阴影贴图的分辨率，也得不到有效的解决。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="图形" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%BD%A2/"/>
    
  </entry>
  
  <entry>
    <title>使用预计算散射的方式实时基于物理的渲染云</title>
    <link href="http://yoursite.com/2019/02/27/%E4%BD%BF%E7%94%A8%E9%A2%84%E8%AE%A1%E7%AE%97%E6%95%A3%E5%B0%84%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%9E%E6%97%B6%E5%9F%BA%E4%BA%8E%E7%89%A9%E7%90%86%E7%9A%84%E6%B8%B2%E6%9F%93%E4%BA%91/"/>
    <id>http://yoursite.com/2019/02/27/%E4%BD%BF%E7%94%A8%E9%A2%84%E8%AE%A1%E7%AE%97%E6%95%A3%E5%B0%84%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%9E%E6%97%B6%E5%9F%BA%E4%BA%8E%E7%89%A9%E7%90%86%E7%9A%84%E6%B8%B2%E6%9F%93%E4%BA%91/</id>
    <published>2019-02-27T15:52:36.000Z</published>
    <updated>2020-11-08T15:40:31.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用预计算散射的方式实时基于物理的渲染云"><a href="#使用预计算散射的方式实时基于物理的渲染云" class="headerlink" title="使用预计算散射的方式实时基于物理的渲染云"></a>使用预计算散射的方式实时基于物理的渲染云</h1><blockquote><p>作者：&lt; GPU Pro 6 &gt; ——-Egor Yusov                                                               译者:losyuffi</p></blockquote><p>​    真实感强烈的云，在游戏中一直是一种需求度很高的东西。云微观上是由会散射光的水分子构成的。在云的渲染中，难点是一束光从一片云射入到射出，要经历多次的散射，而要去模拟，抽样计算散射是比较昂贵的计算。因此，我们需要建立一个相对简单的计算模型来进行模拟。</p><a id="more"></a><p>​    使用面向摄像机的广告牌技术，可能是最普遍的做法了。但是广告牌是一个平面，这在很多视角下会丧失它的立体感。这种方法还有其他限制：光照效果是依靠美术去画的，这也会使它在很多角度看上去会失去真实感。除此之外，体积渲染也是一种渲染云的方法。为了避免锯齿，在同一个方向上通常需要采样多个采样点，这会造成性能瓶颈，尤其是在高分辨率的机器上（PS:体积渲染技术的问题）。当然还有更多，在物理上更精确的方法，使得表现效果更佳，但很难降低计算量，性能消耗较为巨大。</p><p>​    我们发现了一种新的基于物理的方法，且能有效率的渲染云。假定一朵云是由单个被我们称为“参考粒子”的粒子复制后通过扩张或者旋转构成的。在渲染之前，我们可能到达的摄像机位置，对视线上的方向，预计算其深度，和散射积分，并把数据保存。当运行时，我们加载数据，避免消耗大的步进光线采样或者slicing(极线采样)。比较从前的做法，我们做了如下的改进：</p><ul><li>一个更好的实时着色模型，基于预计算查表</li><li>一个使用3D网格计算云内光照衰减的改善方法</li><li>一个新的粒子生成算法</li><li>效率优化，包括GPU粒子的排序</li></ul><p>我们简要回顾了方法的主要概念，在这里我们主要讨论实现细节和改进。其他信息可去查看原始论文</p><h2 id="2-光线传输原理"><a href="#2-光线传输原理" class="headerlink" title="2 光线传输原理"></a>2 光线传输原理</h2><p>现在我们将简单介绍下在传播介质中光传输的主要概念。在传播媒介中，可以发现有三种现象：散射，吸收，以及射出。散射仅仅只改变光线传播的方向，吸收则是吸收光的能量，而射出则与之相反。这三个现象的强度我们用三个参数来进行描述：</p><script type="math/tex; mode=display">\beta_{Sc},\beta_{Ab},\beta_{Em}</script><p>吸收和散射都会减少介质中的光的能量。他的衰减参数:</p><script type="math/tex; mode=display">\beta_{Ex}=\beta_{Ab}+\beta_{Sc}</script><p>在云内部，吸收和射出是可以忽略不计的，即：</p><script type="math/tex; mode=display">\beta_{Em}=\beta_{Ab}=0</script><p>所以散射和衰减可以表述为同一个参数，用：</p><script type="math/tex; mode=display">\beta</script><p>表示。</p><p><img src="https://i.imgur.com/qEJQSXn.png" alt="2.1"></p><p>​    当一束光在云内部，由A点传输到B点的衰减为，我们称为光学深度(Optical Depth)：</p><script type="math/tex; mode=display">\begin{align}& \tau(A,B)=\int_A^B{\beta(P) \cdot ds} \\& 此时P=\frac{B-A}{\mid B-A \mid} ,s是当前的积分点\end{align}\tag{2.1}</script><p>​    为了得到单一光照的被散射后的强度，我们需要使用步进采样进行积分。每一个步进方向：</p><script type="math/tex; mode=display">L_{In}^{(1)}(C,\vec{v})=\int_{P0}^{P1}{\beta(P) \cdot L_{sun} \cdot e^{-\tau(Q,P)}\cdot e^{-\tau(P,P0)} \cdot P(\theta) \cdot ds}\tag{2.2}</script><p>在这个等式中，C是当前摄像机的位置,$\vec{v} $ 是视角方向。P0和P1是云对于视线的入口和出口两点，$L_{Sun}$ 是云外部的阳光强度，Q是阳光到达当前积分点P的点。$P(\theta)$ 是定义 散射出去多少能量的phase函数，$\theta$ 是观察方向PC和出射方向QP的夹角。注意，阳光在到达相机前，会衰减两次：即$e^{-\tau(Q,P)}$ 从阳光入口Q，到达散射点P，和$e^{-\tau(P,P0)}$ 从散射点P，到视线的入口P0</p><p>​    云的phase函数是非常复杂的。在实时渲染方法中，通常使用Cornette-Shanks方法来近似它：</p><script type="math/tex; mode=display">P(\theta) \approx \frac{1}{4\pi}\frac{3(1-g^2)}{2(2+g^2)}\frac{(1+\cos^2(\theta))}{(1+g^2-2g\cos(\theta))^{3/2}}\tag{2.3}</script><p>​    使用单一散射强度$L<em>{In}^{(1)}$ ，我们可以计算二次散射$L</em>{In}^{(n)}$ ，然后三次散射也是如此。然后n次散射强度积分如下</p><script type="math/tex; mode=display">L_{In}^{(n)}(C,\vec{v})=\int_{P0}^{P1}{J^n(P,\vec{v}) \cdot L_{sun} \cdot e^{-\tau(P,P0)}\cdot ds}\tag{2.4}</script><p>在公式2.4中$J^n(C,\vec{v})$ 是n-1阶散射的净强度</p><p><img src="https://i.imgur.com/cALoW1I.png" alt="2.5"></p><script type="math/tex; mode=display">J^n(P,\vec{v})=\beta(P) \cdot \int_\Omega L_{In}^{n-1}(P,\vec{w}) \cdot P(\theta) \cdot dw\tag{2.5}</script><p>这是对P点的整个球面积分，$\vec{w}$是入射方向，$\theta $ 是$\vec{w} 和 \vec{v}$ 的夹角</p><p>总的散射强度计算如下：</p><script type="math/tex; mode=display">L_{In}(C,\vec{v})=\sum_{n=1}^{\infty}L_{In}^{n}(C,\vec{v})\tag{2.6}</script><p>摄像机最终测量的辐射度是总散射强度和背景辐射强度之和：</p><script type="math/tex; mode=display">L(C,\vec{v})=L_{In}(C,\vec{v})+e^{-\tau(P_0,P_1)} \cdot L_B\tag{2.7}</script><h2 id="3-预计算解决方案"><a href="#3-预计算解决方案" class="headerlink" title="3 预计算解决方案"></a>3 预计算解决方案</h2><p>​    上述等式，计算特别复杂，是不可能实时进行计算的。我们的解决这个问题的办法是，对参考体积粒子中的光传输进行建模，在预处理的时候求解出该粒子的所有方程式。而后，我们将结果保存起来，在实时着色时读取。</p><h3 id="3-1-光学深度-Opitical-Depth"><a href="#3-1-光学深度-Opitical-Depth" class="headerlink" title="3.1 光学深度(Opitical Depth)"></a>3.1 光学深度(Opitical Depth)</h3><p>​    考虑一些知道密度分布的不均匀体积粒子。我们的目标是通过粒子为每一个摄像机位置和视图方向预计算公式（2.1）中的光学深度积分。为了描述每一条穿过粒子的射线，我们需要四维向量参数。前两个参数维度是方位角，即球坐标的两个角度$ \varphi<em>S \in [0,2\pi] ,\theta_S \in[0,\pi] $，表示入射点S，后面两个参数也是方位角，即$\varphi</em>\nu \in[0,2\pi],\theta_\nu \in [0,\frac{\pi}{2}]$ 表示在入口点处构建的切线空间中，视线的角度方向。该切线空间的构建中，轴指向球心。因为我们仅仅需要考虑穿过球的视线，所以另外一个角的最大值是 表示在入口点S处构建的切线空间中，视线的角度方向。该切线空间的构建中，z轴指向球心。因为我们仅仅需要考虑穿过球的视线，所以另外一个角的最大值是$\frac{\pi}{2} $。</p><p><img src="https://i.imgur.com/2JuAXf2.png" alt="4.3"></p><p>​    为了预计算光学深度积分，我们遍历所有的$\varphi<em>S,\theta_S,\varphi</em>\nu,\theta_\nu$ ，并利用公式2.1计算其积分值，在3.5中提供细节描述。</p><h3 id="3-2单次散射-Single-Scattering"><a href="#3-2单次散射-Single-Scattering" class="headerlink" title="3.2单次散射(Single Scattering)"></a>3.2单次散射(Single Scattering)</h3><p>​    对比Opitical Depth，我们无法预计算不均匀粒子的散射，原因是，我们需要考虑光线方向，这就需要5个参数了，是不切实际的。所以我们预计算均匀分布球形颗粒中的散射。我们假定光的方向是正z轴，因为光场，相对光是对称的，所以我们可以舍弃 $\varphi<em>S $ ,另一方面，为了计算公式2.5，我们需要知道整个体积的光场，而不仅仅是球表面的光场。因此，我们将从球心到起点的距离作为第四个参数。所以我们计算单次散射的参数为$\theta_S \in [0,\pi] ,\varphi</em>\nu \in[0,2\pi],\theta<em>\nu \in[0,\pi],r \in[0,1]。请注意因为光场需要覆盖整个球面角，所以 。请注意因为光场需要覆盖整个球面角，所以\theta</em>\nu的最大值是 的最大值是\pi$ </p><p>​    然后，是遍历所有参数值，使用2.2公式来预计算单次散射。因为假定了粒子是均匀的，$\beta(P) \equiv \beta$ 。阳光强度$L_{Sun}，和phase函数P(\theta),被分解出来，单独计算$ 细节在3.5.1提及。</p><h3 id="3-3多次散射-Multiple-Scattering"><a href="#3-3多次散射-Multiple-Scattering" class="headerlink" title="3.3多次散射(Multiple Scattering)"></a>3.3多次散射(Multiple Scattering)</h3><p>​    我们使用与单次散射相似的参数对多次散射预处理。为了预计算多次散射，我们逐步执行以下的步骤：</p><ul><li>根据2.5，对所有参数项使用先前的阶数$L_{In}^{n-1}$ 去计算J(n)项</li><li>根据2.4，计算当前次散射$L_{In}^{n}$ </li><li>累加到当前散射序列和之中</li></ul><p>实现细节，在3.5.1中描述</p><p>​    在散射序列计算结束后，我们只保留表面上的光场，丢弃其余的数据。必须注意的是，相对于Optical Depth，在散射中，密集度与粒子半径不是线性相关的。在原始论文中，我们计算了许多密度的散射，并且在4D查找表中，对结果进行了编码，第四个参数是粒子密度的scale。后来发现，仅仅使用一个密度，也工作得挺好，而且简化了算法。</p><p>​    这一步将在3.5.3中进一步讨论</p><h3 id="3-4-Volume-Aware-Blending-粒子融合"><a href="#3-4-Volume-Aware-Blending-粒子融合" class="headerlink" title="3.4 Volume-Aware Blending(粒子融合)"></a>3.4 Volume-Aware Blending(粒子融合)</h3><p>​    我们的云，由一系列的粒子构成，我们需要把他们混合成一个完整的传播媒介。实现这一目标的方法，通常是用alpha 融合。这种方法主要用于薄的物体，比如玻璃或者树叶。我们的粒子是体积渲染实体，没办法使用通用的alpha混合方式进行计算。为了解决这个问题，我们发现了一种新的技术，我们称为“Volume-Aware Blending”。这个技术的关键点是跟踪离摄像机最近的体积元素，针对每一个像素去混和每一个新的粒子。</p><p>​    算法第一步，清掉Closet element Buffer 和 back buffer。然后从后往前渲染体积粒子。针对当前最近的粒子，对每一个粒子进行测试。如果这个粒子比目前的最近粒子更接近相机，那么对最近粒子使用alpha混合，并将颜色写入back buffer，然后使新粒子取代最近粒子。如果新粒子比最近粒子远，那么新粒子就会混合到back buffer里头，最近粒子保持不变。</p><p>​    如果最近粒子与新粒子相交，那么事情就会变得复杂一些。首先把尾部融合进buffer，然后使用密度加权平均的方法融合相交部分的颜色</p><script type="math/tex; mode=display">T_i=e^{-(\rho_0+\rho_1)\cdot d_i \cdot \beta} \\Ci=\frac{C_0 \cdot \rho_0+C_1 \cdot \rho_1}{\rho_0+\rho_1} \cdot(1-T_i)\tag{3.1}</script><p>$C_0,C_1是非alpha预乘颜色，\rho_1,\rho_2是密度，d_i是相交的长度$ 。然后与头部的颜色进行混合后进buffer。</p><h3 id="3-5-实现"><a href="#3-5-实现" class="headerlink" title="3.5 实现"></a>3.5 实现</h3><p>例子是用C++的DXD11 的API实现的，全部的源代码可以在<a href="https://github.com/GameTechDev/CloudsGPUPro6" target="_blank" rel="noopener">Github仓库中</a>找到</p><h4 id="3-5-1-预计算光传输路径"><a href="#3-5-1-预计算光传输路径" class="headerlink" title="3.5.1 预计算光传输路径"></a>3.5.1 预计算光传输路径</h4><p>​    我们将预计算数据做成一个3D一个4D的查找表。Optical Depth的积分保存在一个$32 \times16\times32\times16(N<em>{\varphi s}=32,N</em>{\theta s}=16,N<em>{\varphi \nu}=32,N</em>{\theta \nu}=16)$ 的一个8位LUT(lookup table)中。多次散射保存在一个$32 \times 64 \times16(N<em>{\theta S}=32,N</em>{\varphi \nu}=64,N_{\theta \nu}=16)$ 的16位 float的LUT中。第一个LUT需要0.25MB，第二个则需要64KB。注意与基础方法不同，我们不依赖预计算，而是使用别的方法来近似计算单次散射。</p><p>​    因为当前图形设备不支持4D纹理，我们只能使用3D纹理来进行取代。比如一张$X \times Y \times Z \times W的纹理，我们可以储存成X \times Y \times Z \cdot W$ 的3D纹理。我们对第四个坐标执行手动过滤。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SAMPLE_4D(tex3DLUT,LUT_DIM, f4LUTCoords, fLOD, Result)\</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&#123;\</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">float3 f3UVW0;                                             \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">f3UVW0.xy=f4LUTCoords.xy;\</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> fQSlice=f4LUTCoords.w * LUT_DIM.w <span class="number">-0.5</span>;\</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> fQ0Slice =<span class="built_in">floor</span>(fQSlice);\</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> fQWeight=fQSlice-fQ0Slice;\</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">f3UVW0.z=(fQ0Slice+f4LUTCoords.z)/LUT_DIM.w;\</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/* frac() assures wraparound filtering of w coordinate */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">float3 f3UVW1=frac(f3UVW0+float3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>/LUT_DIM.w));\</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">Result = lerp(\</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        tex3DLUT.SampleLevel(samLinearWrap,f3UVW0,fLOD),\</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        tex3DLUT.SampleLevel(samLinearWrap,f3UVW1,fLOD),\</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        fQWeight\</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">     );\</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>​    注意$\varphi<em>S 和 \varphi</em>\nu$ 坐标需要环绕滤波来避免伪影 。我们使用frac()函数，来让第四个坐标实现这个功能。也要注意z轴是不能使用环绕滤波模式的。</p><p>​    预计算进程可以被总结如下：</p><ul><li>预计算Optical Depth  积分</li><li>预计算单次散射将结果保存在32-bit的浮点型LUT</li><li>计算n次散射 从第2次到第N次：<ul><li>计算$J^n$ 部分</li><li>计算$L_{In}^n$ 部分</li><li>累加$L_{In}^n$ 并存储到LUT中</li></ul></li><li>复制多次散射中，位于球面的结果，保存到最终的16-bit的LUT中</li></ul><p>接下来对每一步的细节进行描述</p><h5 id="Optical-depth"><a href="#Optical-depth" class="headerlink" title="Optical depth."></a>Optical depth.</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">float2  PreComputeOpticalDepthPS(SQuadVSOutput IN):SV_Target</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">float3 f3StartPos, f3RayDir;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//Convert lookup table 4D coordinate into the start position and view direction</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">OpticalDepthLUTCoordsToWorldParams(float4(ProjToUV(In.m_f2PosPS),g_Attribs.f4Params.xy),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">f3StartPos,f3RayDir);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//Intersect the view ray with the unit sphere</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">float2 f2RayIsecs;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//x:first intersect length,y:second intersect length</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//f3StartPos is located exactly on the surface ; slightly move it inside the sphere to avoid       //precision issues</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    GetRaySphereIntersection(f3StartPos + f3RayDir*<span class="number">1e-4</span>,f3RayDir,<span class="number">0</span>,<span class="number">1.f</span>,f2RayIsecs);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    float3 f3EndPos=f3StartPos+f3RayDir*f2RayIsecs.y</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">float</span> fNumSteps=NUM_INTEGRATION_STEPS;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    float3 f3Step = (f3EndPos - f3StartPos) / fNumSteps;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">float</span> fTotalDensity=<span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">float</span> fStepNum=<span class="number">0.5</span>; fStepNum&lt;fNumSteps;++fStepNum)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    float3 f3CurrPos = f3StartPos + f3Step * fStepNum;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">float</span> fDensity=ComputeDensity(f3CurrPos);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    fTotalDensity+=fDensity;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> fTotalDensity/fNumSteps;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>​    需要使用步进算法，一步一步计算。首先计算输入4D坐标，使用OpticalDepthLUTCoordsToWorldParams()函数得出的开始位置和射线方向。4D参数的前两维来自 像素位置，另外两维被存储在g_Attribs.f4Params.xy 变量中。然后继续得到射线与单位圆的交点以及射线离开单位圆的出口。GetRaySphereIntersection()函数中，参数是射线开始坐标，和方向，球的中心点以及半径。然后就是根据公式2.1计算积分。我们不存储积分值，而是存储归一化的平均值。平均值正好能保存在8-bit的的table中。Optical Depth在使用时 将保存的平均数乘上距离即可。ComputeDensity()函数作用是，用pos采样3Dnoise去计算当前点的密度。</p><h5 id="Single-scattering"><a href="#Single-scattering" class="headerlink" title="Single scattering"></a>Single scattering</h5><p>预计算单次散射的片元着色器代码如下。注意单次散射的计算要包含整个体积，而不仅仅是在表面上。使用一张4DLUT储存结果。坐标的第4维编码保存的是到球心的距离，由g_Attribs.f4Params.y提供。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">float  PrecomputeSingleSctrPS(SQuadVSOutput In) : SV_Target</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">float3 f3EntryPoint , f3ViewRay , f3LightDir;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">ScatteringLUTToWorldParams(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">float4(ProjToUV(In.m_f2PosPS), g_Attribs.f4Param.xy),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">g_Attribs.f4Param.z, f3EntryPoint, f3ViewRay, f3LightDir</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">float2 f2RayIsecs;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">GetRaySphereIntersection(f3EntryPoint, f3ViewRay, <span class="number">0</span> , <span class="number">1.f</span> ,f2RayIsecs);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">float3 f3EndPos = f3EntryPoint + f3ViewRay * f2RayIsecs.y;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> fNumSteps = NUM_INTEGRATION_STEPS;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">float3 f3Step = (f3EndPos - f3EntryPoint) / fNumSteps;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> fStepLen = length(f3Step);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> fCloudMassToCamera = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> fParticleRadius = g_Attribs.RefParticleRadius;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> fInscattering = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">float</span> fStepNum=<span class="number">0.5</span>,fStepNum &lt; fNumSteps; ++fStepNum)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    float3 f3CurrPos = f3EntryPoint + f3Step * fStepNum;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    GetRaySphereIntersection(f3CurrPos, f3LightDir, <span class="number">0</span> , <span class="number">1.f</span> ,f2RayIsecs);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">float</span> fCloudMassToLight = f2RayIsecs.x * fParticleRadius;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">float</span> fAttenuation = <span class="built_in">exp</span>( </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    -g_Attribs.fAttenuationCoeff *</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    (fCloudMassToLight + fCloudMassToCamera)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    fInscattering += fAttenuation * g_Attribs.fScatteringCoeff;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    fCloudMassToCamera += fStepLen * fParticleRadius;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> fInscattering * fStepLen * fParticleRadius;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>​    算法是依据公式2.2实现的。注意phase函数$P(\theta ) 和 阳光强度 L_{Sun}$被忽略了。因此着色器在每一步，需要去计算该式的积分:$\beta(P) \cdot e^{-\tau(Q,P)} \cdot e^{-\tau(P,P_0)}$ ，散射衰减因数$\beta(P)$被看作是一个常数，由g_Attribs.fScatteringCoeff 变量提供。 我们使用的 $\beta =0.07$ 作为散射衰减系数。一个参考粒子（reference particle）的半径为200米。衰减$e^{-\tau(Q,P )}$ 是从当前点到光线与粒子球的交点入口的衰减。衰减$e^{-\tau(P,P_0)}$ 朝向摄像机部分的衰减是由云的所有mass表示的，使用fCloudMassToCamera变量进行累加。</p><h5 id="Multiple-scattering"><a href="#Multiple-scattering" class="headerlink" title="Multiple scattering"></a>Multiple scattering</h5><p>在单次散射之后，我们计算了N=18次的多次散射。在这一阶段，我们使用了3张-4D 32-bit 的浮点型LUT：一张存储$J^n$部分，一张存储当次散射$L_{In}^n$ 。第三张，则存储所有次散射混合的结果。</p><p>关于$J^n$ 的计算代码如下;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">float GatherScatteringPS(SQuadVSOutput In) :SV_Target</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">float3 f3StartPos, f3ViewRay , f3LightDir;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">ScatteringLUTToWorldParams</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">float4(ProjToUV(In.m_f2PosPS),g_Attribs.f4Param.xy),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">f3StartPos, f3ViewRay , f3LightDir</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">float3 f3LocalX, f3LocalY, f3LocalZ;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">ConstructLocalFrameXYZ(-normalize(f3StartPos), f3LightDir, </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">f3LocalX,f3LocalY,f3LocalZ);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> fJ=<span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> fTotalSolidAngle=<span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> fNumZenithAngles = SCTR_LUT_DIM.z;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> fNumAzimuthAngles = SCTR_LUT_DIM.y;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> fZenithSpan = PI;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> fAzimuthSpan = <span class="number">2</span>* PI;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">float</span> Zen = <span class="number">0.5</span>;Zen &lt; fNumZenithAnles; ++Zen)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">float</span> Az = <span class="number">0.5</span>; Az &lt; fNumAzimuthAngles; ++Az)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">float</span> fZenith= Zen/fNumZenithAngles * fZenithSpan;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">float</span> fAzimuth = (Az / fNumAzimuthAngles - <span class="number">0.5</span>) * fAzimuthSpan;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        float3 f3CurrDir = GetDirectionInLocalFrameXYZ(f3LocalX, f3LocalY, f3LocalZ, fZenith, fAzimuth);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        float4 f4CurrDirLUTCoords = WorldParmasToScatteringLUT(f3StartPos,f3CurrDir,f3LightDir);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">float</span> fCurrDirSctr = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">        SAMPLE_4D(g_tex3DPrevSctrOrder , SCTR_LUT_DIM, f4CurrDirLUTCoords, <span class="number">0</span> , fCurrDirSctr);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(g_Attribs.f4Param.w == <span class="number">1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">        fCurrDirSctr *=HGPhaseFunc(dot(-f3CurrDir,f3LightDir),<span class="number">0.9</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">        fCurrDirSctr *=HGPhaseFunc(dot(f3CurrDir,f3ViewDir),<span class="number">0.7</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">float</span> fdZenithAngle = fZenithSpan / fNumZenithAngles;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">float</span> fdAzimuthAngle = fAzimuthSpan / fNumAzimuthAngles *  <span class="built_in">sin</span>(ZenithAngle);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">float</span> fDiffSolidAngle = fdZenithAngle * fdAzimuthAngle;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">        fTotalSolidAngle += fDiffSolidAngle;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">        fJ += fCurrDirSctr * fDiffSolidAngle;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">    fJ *= <span class="number">4</span>* PI / fTotalSolidAngle;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> fJ;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>这部分代码，第一步是从4Dtexture中取到世界空间下的参数(3-6行)，与之前的代码类似。之后的步骤是构建局部转换矩阵（8-10行）。这个函数需要两个向量当作输入来构建正交基。第一个向量使用z轴，注意z轴是指向球心的。</p><p>​    然后构建两个循环，迭代zenith $ \theta$ 和 azimuth $\varphi$ (18-19行) 。在每一步迭代中，着色器使用($ \theta,\varphi $) 构建了采样方向。从转换这个方向为可采样的参数（26-28行）读取该方向上第n-1次散射(29-31行)。记得我们在计算单次散射的时候，没有计算phase 函数的。如果有必要，我们在这一步添加（32-34行）g_Attribs.f4Param.w的值是如果这是第二次散射则为1否则为0。之后我们用公式2.5计算phase 函数（35行），对于单次散射的各向异性系数我们使用0.9，而多次散射我们则使用0.7。最后计算$dw=d\theta \cdot d \varphi \cdot \sin{\theta}$ 部分(37-40行)</p><p>​    在$J^n$ 部分计算完成后，我们接着计算第n次散射。这部分与之前的单次散射十分类似，只需要把$J^n$ 读取出来，使之代替单次散射中的阳光衰减，我们还使用了梯度积分来提高准确性。</p><p>​    第三阶段，便是，取出各次散射，并进行加法混合，并将累积结果存储起来。</p><h4 id="3-5-2-粒子生成"><a href="#3-5-2-粒子生成" class="headerlink" title="3.5.2 粒子生成"></a>3.5.2 粒子生成</h4><p>​    当我们渲染云的时候，我们想要能有效率的做LOD和对近处的云提供叫高的真实度。为了完成这个，我们使用了一个网格嵌套数据结构，这种结构的灵感来自几何图形贴图。每一个外环中的粒子是其内环中粒子的两倍大小，其粒子间距也是两倍。我们将这种结构称为一个单元网格。一个网格中的单元包含一个预定义数目的层数。每一个三维结构结果中的体素可能包含一个粒子。我们称这种结构是粒子格子。为了加速粒子生成和光照</p><p><img src="https://i.imgur.com/dJyJb67.png" alt="Cell Grid and 3D lattice"></p><p>我们维护了两个3D数据结构：云密度3D格子 和 光照衰减3D格子。这两个结构的分辨率每一维都是一个粒子格子的两倍，而且是使用3D贴图实现的。</p><p>粒子生成的过程如下：</p><ul><li>处理一张2D 单元网格，去建立一个有效非空单元列表，并计算每一个单元的属性</li><li>计算位于非空单元中每一个云密度格子中的每一个voxel</li><li>处理位于非空单元中每一个光照衰减格子中的每一个可见的voxel</li><li>处理粒子格子，为可见的单元且密度超过了阈值的粒子格子生成粒子。</li><li>处理粒子并储存光照信息</li><li>对粒子排序</li></ul><p>以上步骤的实施是通过一个compute shader去实现的。我们基于GPU去实现它，CPU不知道每一个Kernel，GPU需要多少的线程去运行。我们使用Dispatch Indirect() 函数来让GPU自己给自己分配。这个函数的参数和Dispatch()是一样的，但是这些参数是被储存在GPU Buffer中的，这就允许GPU控制它自己。我们接下来讨论，每一步的细节·</p><h5 id="Processing-cell-grid"><a href="#Processing-cell-grid" class="headerlink" title="Processing cell grid"></a>Processing cell grid</h5><p>处理单元网格，是使用compute shader来完成的，为每一个单元分配一个线程。它负责基于摄像机的世界空间坐标计算每一个单元的中心点以及大小。使用计算出的单元中心位置，通过组合两个2Dnoise函数计算单元的基础密度。如果求出的结果超过阈值，那么就说明这个单元是合法的。着色器将所有合法的单元Append进Buffer中（g_ValidCellsAppendBuf）。最后能得到一个未排序的列表。如果单元在摄像机裁剪矩阵内，即是可见的，那么着色器将会把这些单元Append进另一个保存着所有可见的单元Buffer中(g_VisibleCellsAppendBuf)。</p><h5 id="Processing-cloud-density-lattice"><a href="#Processing-cloud-density-lattice" class="headerlink" title="Processing cloud density lattice"></a>Processing cloud density lattice</h5><p><img src="https://i.imgur.com/MUB9UpB.png" alt="Valid cells"></p><p>下一个阶段，我们需要处理在合法单元网格内的那些lattice中的voxel。为了计算这些，需要一定数量的GPU线程，我们执行了一个简单的单线程compute shader：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">RWBuffer&lt;uint&gt; g_DispatchArgsRW : <span class="keyword">register</span>(u0);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">[numthread(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ComputeDispatchArgsCS</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    uint s = g_GlobalCloudAttribs.uiDensityBufferScale;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    g_DispatchArgsRW[<span class="number">0</span>] = (g_ValidCellsCounter.Load(<span class="number">0</span>) * s *s *s *</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">                          g_GlobalCloudAttribs.uiMaxLayers + THREAD_GROUP_SIZE<span class="number">-1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        /THREAD_GROUP_SIZE;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>先前被写入buffer的元素可以用CopyStructureCount()函数拷贝进一个合适被读取的资源中。然后将先前作为UAV绑定到g_DispatchArgsRW的缓冲区传递给DispathIndirect()函数，以生成所需数量的线程。每一个线程读取g_ValidCellsUnorderedList Buffer中的合法单元，在上阶段被填满的cell内容，找出它在这个单元的位置。然后这个shader结合两个3Dnoise函数，创建一个单元密度的体积噪声。该噪声的幅度，随着高度降低，以产生典型的体积云形状，具有更宽的底部，和更窄的顶部。</p><h5 id="Light-attenuation"><a href="#Light-attenuation" class="headerlink" title="Light attenuation"></a>Light attenuation</h5><p>光照衰减是在每一个可见单元中的每一个voxel中被计算的。为了完成计算，我们需要分配一定数量的线程。使用与前阶段类似的方式，但是这次我们提供了具有合法性和可见性的单元buffer g_ValidCellsCounter变量。光照衰减是投一从voxel的中心朝光照方向的射线，通过密度lattice进行步进采样而计算出的。我们执行了16次步进。我们存储云衰减的mass系数，而不是直接存储光照衰减，是因为云衰减的mass能更好的被插值。</p><h5 id="Particle-generation"><a href="#Particle-generation" class="headerlink" title="Particle generation"></a>Particle generation</h5><p>下一阶段，是处理cloud lattice中的有效可见的voxel，并为其中一些生成粒子。执行这一步，需要分配一定数目的线程。我们再次使用了简单的单线程compute shader。粒子生成器shader加载了云的密度，从密度lattice上，如果它不是0，那么就要创建粒子。shader随机的替换voxel中心的粒子，并加上一个随机的旋转和scale，以消除样式的重复性。着色器会将属性，比如粒子的坐标位置，密度，大小，写入粒子信息buffer中，并将粒子索引写入另一个append buffer中(g_VisibleParticlesAppendBuf)。</p><h5 id="Processing-visible-particles"><a href="#Processing-visible-particles" class="headerlink" title="Processing visible particles"></a>Processing visible particles</h5><p>这一步，需要计算光照信息。特别是，我们在计算射到粒子中心的阳光颜色时，忽略了云的遮挡和周围天光的强度。我们也会采样光照衰减mass的贴图去计算光照遮挡。我们使用粒子表面的值去计算多次散射的衰减，用粒子中心的值去计算单次散射的衰减。此外，当计算多次散射的衰减时，我们让光照-衰减mass乘上一个0.25的系数去计算前向的强散射。</p><h5 id="Sorting"><a href="#Sorting" class="headerlink" title="Sorting"></a>Sorting</h5><p>在粒子能被正确渲染前，将粒子从后往前排序是最后的阶段了。在我们最开始的论文时，我们将粒子lattice的voxel排序是用CPU完成的，然后只有可见有效的voxel会从GPU中流出（用GPU做voxel的可见性和有效性判定）。这导致了一定数目的Drawbacks，首先他需要激活CPU-GPU通话。第二，由于随机的offset，粒子顺序和体素顺序可能有些微不同。但是主要的问题是，所有的voxel都会被排序，即使它们大部分是空的，这导致了CPU的overhead</p><p>我们现在将排序粒子完全用GPU去做，使用Satish et al 的合并排序算法（一个简化的合并算法程序）。我们开始时，将可见列表的粒子细分为128个粒子的子序列，并使用bitonic排序对每个子序列进行排序。然后我们执行合并操作，将已排好序的子序列合并成一个序列。当执行二进制搜索寻找其序号时，我们直接访问全局内存。因为需要排序的粒子相对较少通常不会超过50000，整个列表可以存入缓存，解释我们不适用共享内存，合并仍然非常有效。</p><p>重要的一点是，我们不知道GPU上生成了多少粒子以及我们需要执行多少次合并。因此我们执行了足够多数目的Pass，来对最大可能的粒子数目进行排序。当不需要再完成其他任务时，compute shader提前退出工作，性能成本时非常低的。</p><h4 id="3-5-3-渲染"><a href="#3-5-3-渲染" class="headerlink" title="3.5.3 渲染"></a>3.5.3 渲染</h4><p>当前期的粒子生成，预处理和排序完成后，就可以进行渲染了。因为只有GPU知道我们生成了多少的粒子，所以我们使用DrawInstancedIndirect。它的使用与DrawInstance类似，只是它的参数，来自GPU Buffer。我们读取每一个应该可见的粒子，并从它的属性中读取数据，生成它的BoundingBox，最后将其送入光栅化流程。</p><p>在片元着色器中，我们对视线与粒子的bounding box求交，如果不相交，就Discard产生这条射线的这个像素。此外我们的着色模型是基于预计算的LUT的，正如下述代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//Compute lookup coordinates</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">float4 f4LUTCoords;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">WorldParamsToOpticalDepthLUTCoords(f3EntryPointUSSpace, f3ViewRayUSSpace, f4LUTCoords);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//Randomly rotate the sphere</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">f4LUTCoords.y += ParticleAttrs.fRndAzimuthBias;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//Get the normalized density along the view ray</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> fNormalizedDensity = <span class="number">1.f</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">SAMPLE_4D_LUT(g_tex3DParticleDensityLUT, OPTICAL_DEPTH_LUT_DIM, f4LUTCoords, <span class="number">0</span>, fNormalizedDensity);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//Compute actual cloud mass by multiplying the normalized</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//density with ray length</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">fCloudMass = fNormalizedDensity * fRayLength;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">fCloudMass *= ParticleAttrs.fDensity; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//Compute transparency</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">fTransparency = <span class="built_in">exp</span>( -fCloudMass * g_Attribs.fAttenuationCoff);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//Evaluate phase function for single scattering</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> fCosTheta =dot(-f3ViewRayUSSpace, f3LightDirUSSpace);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> PhaseFunc = HGPhaseFunc(fCosTheta, <span class="number">0.8</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">float2 f2Attenuation = ParticleLighting.f2SunLightAttenuation;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//Compute intensity of single scattering</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">float3 f3SingleScattering = fTransparency * ParticleLighting.f4SunLight.rgb *</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">f2Attenuation.x * PhaseFunc;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//Compute lookup coordinates for multiple scattering</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">float4 f4MultSctrLUTCoords = WorldParamsToScatteringLUT(f3EntryPointUSSpace ,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"> f3ViewRayUSSpace, f3LightDirUSSpace);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//Load multiple scattering from the lookup table</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> fMultipleScattering = g_tex3DScatteringLUT.SampleLevel( samLinearWrap,f4MultSctrLUTCoords.xyz, <span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">float3 f3MultipleScattering = </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">    (<span class="number">1</span>-fTransparency) * fMultipleScattering * </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    f2Attenuation.y * ParticleLighting.f4SunLight.rgb;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//Compute ambient light</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">float3 f3EarthCentre = float3(<span class="number">0</span>, -g_Attribs.fEarthRadius, <span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> fEnttryPointAltitude <span class="title">length</span><span class="params">(f3EntryPointWS - f3EarthCentre)</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> fCloudBottomBoundary =</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">    g_Attribs.fEarthRadius + g_Attribs.fCloudAltitude - g_Attribs.fCloudThickness / <span class="number">2.f</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> fAmbientStrength =</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">    (fEnttryPointAltitude - fCloudBottomBoundary) / g_Attribs.fCloudThickness;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">fAmbientStrength = clamp(fAmbientStrength,<span class="number">0.3</span>,<span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">float3 f3Ambient = (<span class="number">1</span>-fTransparency) * fAmbientStrength * ParticleLighting.f4AmbientLight.rgb;</span></pre></td></tr></table></figure><p>我们的第一步是计算密度,使用OpticalDepthLUT,我们随机的围绕垂直轴旋转一个角度，来减少重复度。f3EntryPointUSSpace和f3ViewRayUSSpace 是粒子空间下的起点和射线方向。（因为是单位圆空间，所以后缀是US）。接下来我们计算透明度</p><p>我们的实时渲染由三部分组成：单次散射，多次散射，和环境光。我们在第20-27行计算了单次散射。他是日照强度和日照衰减以及相位函数的乘积。因为单次散射在云密度低的地方最为明显，所以我们乘上一个透明度。</p><p>接下来我们计算多次散射。我们乘上了光照衰减强度。因为多次散射发生在云的密集区域，所以我们还要乘上不透明度（1-fTransprency）。</p><p>最后我们对环境光效果做一个近似。环境光的强度，在顶部边界是最强的，越往底部，越小。下图显示的是每一过程的结果</p><p><img src="https://i.imgur.com/3TKYlxZ.png" alt=""></p><blockquote><p>从左到右，依次是单次散射，多次散射，环境光，以及所有结果之和</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;使用预计算散射的方式实时基于物理的渲染云&quot;&gt;&lt;a href=&quot;#使用预计算散射的方式实时基于物理的渲染云&quot; class=&quot;headerlink&quot; title=&quot;使用预计算散射的方式实时基于物理的渲染云&quot;&gt;&lt;/a&gt;使用预计算散射的方式实时基于物理的渲染云&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;作者：&amp;lt; GPU Pro 6 &amp;gt; ——-Egor Yusov                                                               译者:losyuffi&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;​    真实感强烈的云，在游戏中一直是一种需求度很高的东西。云微观上是由会散射光的水分子构成的。在云的渲染中，难点是一束光从一片云射入到射出，要经历多次的散射，而要去模拟，抽样计算散射是比较昂贵的计算。因此，我们需要建立一个相对简单的计算模型来进行模拟。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="图形" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%BD%A2/"/>
    
  </entry>
  
  <entry>
    <title>大气散射（译文）</title>
    <link href="http://yoursite.com/2018/11/20/%E5%A4%A7%E6%B0%94%E6%95%A3%E5%B0%84%EF%BC%88%E8%AF%91%E6%96%87%EF%BC%89/"/>
    <id>http://yoursite.com/2018/11/20/%E5%A4%A7%E6%B0%94%E6%95%A3%E5%B0%84%EF%BC%88%E8%AF%91%E6%96%87%EF%BC%89/</id>
    <published>2018-11-19T16:14:55.000Z</published>
    <updated>2020-11-08T15:40:31.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="大气光散射（译文）"><a href="#大气光散射（译文）" class="headerlink" title="大气光散射（译文）"></a>大气光散射（译文）</h1><p>[TOC]</p><h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h2><p>​    大气光散射是一种重要的自然现象，它是由光与传播介质中的粒子相互作用产生的。许多应用程序都需要用到这种效果，比如电脑游戏，为了提高场景的真实度，需要这种效果。为了精确计算散射分布，需要求解像素级的多重嵌套积分。由于涉及到算法的复杂度过高，因此在实时渲染中，实现大气散射是一个具有挑战性的难题。</p><p>​    该文章介绍了一种利用极线采样来显著减少计算的光线行进的样本数量，的体积光渲染方法</p><a id="more"></a><h2 id="2-光散射基础知识"><a href="#2-光散射基础知识" class="headerlink" title="2. 光散射基础知识"></a>2. 光散射基础知识</h2><p>​    光通过介质时，主要会产生三种现象：</p><ul><li>吸收是指电磁能转换为其他形式的能量，比如热量</li><li>排放是辐射电磁能量</li><li>散射是改变光的方向</li></ul><p>​    空气的排放和吸收可以忽略不计，所以我们只需要考虑散射即可。从理论上讲，光子可以经历多次散射后到达人的眼睛。但是光在介质中多次散射的传输方程，很难计算。因此，实施渲染时通常使用单次散射模型。即假定光在介质中仅散射一次，且不考虑进一步的散射。</p><p>​    散射效应通过两种方式影响场景对象，这种现象称为空气透视。一种是阳光通过散射进入摄像机，而另一方面本该射入摄像机的目标物体的反射光也会由于散射而产生衰减。因此，在相机处测量的最终辐射是两种辐射的总和：目标物体的衰减辐射和光源的散射</p><script type="math/tex; mode=display">\begin{align}L=L_0*F_{ex}+L_{inscattering}\end{align}</script><p><img src="https://software.intel.com/sites/default/files/ls-image003.png" alt="Fig.1"></p><p>​                                    图1. 散射效应产生的空气透视现象</p><ul><li>光照强度L是一个由3个变量求得的函数：位置参数x，方向v和波长λ</li><li>空间中任意一点的散射通过两个参数描述：取决于位置和波长的散射系数 β(x,λ)，和以视角和光线方向为参数的相位函数ρ(v,l)。</li></ul><p>散射函数描述的是任意方向上单位长度的光的散射部分。相位函数描述了散射光的角度分布。依照能量守恒，相位函数积分：</p><script type="math/tex; mode=display">\int_Ω{ρ(v,l)dω=1}</script><p>表示所有方向上的相位函数之和为1</p><p>接下来让我们来考虑等式的两个部分：</p><script type="math/tex; mode=display">衰减F_{ex} 和散射L_{inscattering}</script><h3 id="衰减"><a href="#衰减" class="headerlink" title="衰减"></a>衰减</h3><p>​    每一截面长度的光的散射能量（微分）ds，与光的强度和散射系数，以及截面长度成正比:</p><script type="math/tex; mode=display">dL_{Sctr}(x,v,λ)=β(x,λ)●L(x,v,λ)●ds</script><p>举例来说，比如我们要求相机C接收到物体A传来的衰减光：</p><script type="math/tex; mode=display">L(C,v,λ)=L_0e^{-\int_C^O{β(x,λ)ds} }</script><p>上式中，L0为物体O点的初始光照，在乘上C到O的衰减积分后，得到最终相机接收到的衰减光照。</p><p>到这里，我们很容易提取出衰减系数的公式如下（A点到B点的衰减）：</p><script type="math/tex; mode=display">F_{ex}(A,B,λ)=e^{-\int_A^B{β(x,λ)ds}}</script><h3 id="散射"><a href="#散射" class="headerlink" title="散射"></a>散射</h3><p>散射部分，计算起来要更加复杂一些。我们需要再次使用公式:</p><script type="math/tex; mode=display">dL_{Insctr}(x,v,λ)=E_{sun}(x,λ)●β(x,λ)●V(x)●ρ(v,l)</script><p>但是此时我们不再把它看成物体投向摄像机过程的散射，而是阳光或其他光源投向摄像机的散射。它正比于太阳的光照强度，还必须通过使用相位函数调制，来获取更精确的散射分量（衰减函数未使用相位函数调制）。由于阴影的原因，我们还需要考虑太阳散射的可见性。可见为1，不可见为0。由此，得出上式</p><p><img src="https://software.intel.com/sites/default/files/ls-image026.png" alt=""></p><p>​                                图2. 散射的能量分布的微分</p><p>这种散射光在到达相机之前会衰减。如果我们将当前位置表示为：</p><script type="math/tex; mode=display">P=C+vs</script><p>那么整个散射光的分布表示如下:</p><script type="math/tex; mode=display">L_{insctr}(c,v,λ)=\int_C^O{dL_{insctr}(x,v,λ)●F_{ex}(P,C,λ)}</script><h3 id="空气的散射参数"><a href="#空气的散射参数" class="headerlink" title="空气的散射参数"></a>空气的散射参数</h3><p>空气通常把它看作由两种分子混合的介质：分子和气溶胶。根据瑞利散射（一种光学理论），当例子的半径r&lt;0.1λ时，即属于瑞利散射。散射的能量分布概率取决于光的方向，以及散射方向的夹角。瑞利粒子的归一化相位函数如下:</p><script type="math/tex; mode=display">ρ(θ)=\frac{3}{16π}(1+cos^2θ)</script><p>大气分子的散射取决于波长，波长短的散射要比波长长的散射更大，这就是为什么天空是蓝色的原因。当然这仅是气体分子，而气溶胶的散射更复杂，它的散射能使用米氏理论描述。在大气散射中，关于雾度的米氏相位函数通常用Henyey-Greenstein相位函数进行近似:</p><script type="math/tex; mode=display">ρ_{Mie}(θ)=\frac{1-g^2}{4π(1+g^2-2g\cos{θ})^{s/2}}</script><p>关于瑞利粒子和米氏(Mie)粒子的散射系数推导可搜索相关关键词了解更多</p><h3 id="假设"><a href="#假设" class="headerlink" title="假设"></a>假设</h3><p>上述计算中，涉及的积分通常是很难计算的，所以通常会进行一些简化。为了简化计算，我们做出如下的假设：</p><ul><li><p>散射系数不依赖于空间中的位置，即假设传播的介质是均匀的：</p><script type="math/tex; mode=display">β(x,λ)=β(λ)</script></li><li></li></ul><script type="math/tex; mode=display">E_{sun}(x,λ)=E_{sun}(λ)</script><p>这样的简化，对于地面的散射效应渲染是合理的。</p><p>基于这样的假设那么衰减系数可变化为:</p><script type="math/tex; mode=display">\begin{align}F_{ex}(A,B,λ) &=e^{-\int_A^B{β(x,λ)ds}}\\&=e^{-(β_{Rlgh}(λ)+β_{Mie}(λ))\int_A^Bds}\\&=e^{-(β_{Rlgh}(λ)+β_{Mie}(λ))||A-B||}\end{align}</script><p>||A-B||表示A点到B点的距离</p><p>现在我们来重写散射能量的公式：</p><script type="math/tex; mode=display">\begin{align}L_{insctr}(c,v,λ) &=\int_C^O{dL_{insctr}(x,v,λ)●F_{ex}(P,C,λ)}\\&=E_{sun}(λ)\frac{(β_{Rlgh}(λ)ρ_{Rlgh}(θ)+β_{Mie}(λ)ρ_{Mie}(θ))}{β_{Rlgh}(λ)+β_{Mie}(λ)}\int_C^O{V(x)●exp(-(β_{Rlgh}(λ)+β_{Mie}(λ))s)}\end{align}</script><p>我们做如下定义：</p><script type="math/tex; mode=display">F(λ,θ)=E_{sun}(λ)\frac{(β_{Rlgh}(λ)ρ_{Rlgh}(θ)+β_{Mie}(λ)ρ_{Mie}(θ))}{β_{Rlgh}(λ)+β_{Mie}(λ)}\\I(λ,s)=-exp(-(β_{Rlgh}(λ)+β_{Mie}(λ))s)</script><p>然后我们就可以将公式改写成：</p><script type="math/tex; mode=display">L_{insctr}(c,v,λ)=F(λ,θ)●(1+I(λ,||O-C||))</script><p>由于在阴影区域，应该没有散射能量。如图三</p><p><img src="https://software.intel.com/sites/default/files/ls-image049.png" alt=""></p><p>​                                    图3. 将视图的光暗区域进行划分</p><p>我们将光亮区域划分为一个[S,E]段,那么散射公式如下:</p><script type="math/tex; mode=display">\begin{align}L_{insctr}(c,v,λ) &=\sum_{i=0}^N(L_{insctr}^{l}(E_i,v,λ)-(L_{insctr}^{l}(S_i,v,λ)))\\&=F(λ,θ)●\sum_{i=0}^N(I(λ,||E_i-C||)-I(λ,||S_i-C||))\end{align}</script><p>得到上述的公式后，我们就可以制定我们用于计算散射积分的初始算法了:</p><ol><li><p>将光线分成N段</p></li><li><p>让L(insct).rgb=0  I(prev).rgb=-1</p></li><li><p>让每一段进行下述计算:</p><p>a. 计算I(current).rgb=I(λ(rgb),d) ,d是当前段的长度</p><p>b. 如果当前段，不在影子当中，那么L(insct).rgb+=I(current).rgb-I(prev).rgb</p><p>c.I(prev).rgb=I(current).rgb</p></li><li><p>最后再乘上F(λ(rgb),θ)</p><p>​                算法1：计算散射积分</p></li></ol><p>其实就是一个完成上述公式的算法过程。</p><h2 id="3-极线采样"><a href="#3-极线采样" class="headerlink" title="3. 极线采样"></a>3. 极线采样</h2><p>​    为了应用体积光效果，我们需要从摄像机的屏幕的每一个像素点投射一道光线去执行算法1，但是这种做法计算太大，太耗费资源了。所以需要找到一个方法去减少计算量。Light shaft（光轴）在屏幕上看来有一个特别的结构：即它们都是从屏幕上的光源点辐射出来的。Engelhard和Dachsbacher注意到散射光和光轴成正交变换，但是大部分是光滑变化的。为了解释这个特性，他们提出了一个有效的采样方案。他们的想法是沿着光轴，也就是从太阳位置到屏幕边缘的极线上进行射线行进采样（Ray Marching），并且在采样点之间设置额外的插值采样点。因为光照强度在射线上光滑变化，所以可以利用Ray marching的采样点的强度来进行线性插值，得到其他位置的强度。</p><p>​    <img src="https://software.intel.com/sites/default/files/ls-image059.png" alt="0"></p><p>​                    图4. 使用步进采样（RayMarching）和插值采样点的极线采样</p><p>​    Engelhard和Dachsbacher提出的算法步骤如下：</p><ul><li>将场景渲染到屏幕空间</li><li>计算散射分布<ul><li>在深度间隔处放置采样点</li><li>使用步进采样点对其它采样点进行插值</li><li>使用来自附近的极线采样点的插值计算每个像素的散射</li></ul></li><li>散射与背景光的衰减进行组合（add）</li></ul><p>在我们的实现中，我们遵循了Engelhardt和Danchsbacher的基本思想，并在第5节讨论了一些改进和修改</p><h2 id="4-一维-最小-最大-mipmap优化"><a href="#4-一维-最小-最大-mipmap优化" class="headerlink" title="4.一维 最小/最大 mipmap优化"></a>4.一维 最小/最大 mipmap优化</h2><p>​    极线采样有一个重要的特点：在一个极片中的相机光线，共享同一个平面。该平面与阴影贴图的交点形成了一个一维高度图。算法1中的阴影测试的本质是检查光线上当前的位置是在该高度图之下还是在其上方。</p><p>​    <img src="https://software.intel.com/sites/default/files/ls-image060.png" alt=""></p><p>​                图5 . 一个极平面上所有的光线进行利用一维高度图进行测试</p><p>​    为了加速步进算法的进行，提出了为每个极线片面构建一个最小最大的二叉树，然后使用它来鉴定光线上的亮部和暗部。</p><p>​    <img src="https://software.intel.com/sites/default/files/ls-image061.png" alt=""></p><p>​                图6. 极线切面上的第一层最大最小二叉树</p><p>​    考虑图7.如果当前光线末端的最大深度小于二叉树上的最小深度，那么那么当前部分就是亮部，我们可以加入散射给当前段。对于AB部分而言满足条件时:</p><script type="math/tex; mode=display">AB: max(d_A,d_B)<d_{min}</script><p>这意味着，算法1中接下来的四次迭代，光线都处于光亮部分（因为这是二叉树的第二层）。因此我们可以仅做一次没有阴影的计算而不需要进行四次迭代，因为它们的结果是一样的。</p><p>​    另一种情况，如果光线末端的最小深度大于二叉树中的最大深度，即这部分光线完全处于阴影当中，我们可以完全抛弃它们。对于CD部分而言满足条件时:</p><script type="math/tex; mode=display">CD:min(d_C,d_D)>d_{max}</script><p>这种情况下，算法1中我们可以推进接下来的四次迭代（无视该四次迭代的计算）而不会产生任何错误。</p><p>​    当然也有可能遇到EF段这种情况。在这种情况下有必要进入到树的下一个层级进行更精细的测试。</p><p>​    因为实际使用中，我们使用默认的depth buffering ，所以所有的检测都是颠倒的</p><p><img src="https://software.intel.com/sites/default/files/ls-image064.png" alt=""></p><p>​                        图7. 使用第二层树来决定亮部或者暗部</p><p>​    上述二叉树遍历算法本质上是光线、高度图的交集方法的改编，其中遍历不是使用递归完成的。利用上述的高度图二叉树，可以对算法1进行改进。注意，光线步进是在阴影贴图空间中完成的。为此，光线的终点投影到阴影贴图上，然后沿着投影线进行采样：</p><p>​    1.将Camera的光线投影到阴影空间的深度贴图上，计算出</p><script type="math/tex; mode=display">UV_{Start},UV_{End},UV_{Step}</script><p>​    2.设置初始值:</p><script type="math/tex; mode=display">L_{Insct}.rgb=0, PrevI.rgb=-1</script><p>​    3.设置树的层数Index：</p><script type="math/tex; mode=display">Level=0,SampleInd=0</script><p>​    4.设置变量：</p><script type="math/tex; mode=display">UV=UV_{start}</script><p>​    5.当射线march 到时（不好翻译，需要了解Ray March算法），执行以下操作：</p><p>​        5.1  </p><script type="math/tex; mode=display">if(SampleInd \mod 2^{Level+1}) ==0\\Then: Level=Level+1</script><p>​        5.2 当 Level&gt;0时，迭代，计算光线段的开始点和结束点的深度得到:</p><script type="math/tex; mode=display">d_{Start}和d_{End}</script><p>​        5.2.1</p><p>​        </p><h2 id="5-算法"><a href="#5-算法" class="headerlink" title="5.算法"></a>5.算法</h2><p>​    我们的算法结合了极线采样方法和一维最小/最大mipmap的优化算法。主要步骤如下：</p><ol><li>首先将带光源的场景渲染出来</li><li>从深度缓冲区中拿到深度，依据它重建一个线性的屏幕空间（可自定义，可以理解为一张自定义的用来做散射的深度图）</li><li>建立一个一维 min/max mipmap</li><li>渲染纹理坐标贴图：<ol><li>首先定义屏幕边界上的极点数目，需要保证所有相邻极点之间的空隙是等距的。将每一个极点，连接到光源点上，得到极线，每一个极点到光源点的连线线段就是极线。而我们的采样点就是沿着每一条极线均匀放置的。</li><li>如果光源在屏幕外，采样点设置时忽略掉，超出屏幕的位置。</li></ol></li><li>检测深度的间断位置，并且定义采样点的初始位置<ol><li>在没有遮挡光的物体时，采样点初始设置是用来获取光的变化的。</li><li>额外设置采样点，在相邻像素之间的Z差异（自定义深度图采样值）超过阈值的位置处</li></ol></li><li>对设置的采样点执行Ray marching</li><li>利用Ray marching 计算出的散射光照，插值算出其他的采样点的散射光照</li><li>将散射采样点转换空间，从极坐标转换到缩小尺寸的矩形缓冲中<ol><li>确定两条最邻近的极线</li><li>将采样点投射到极线上，并利用Z差异，进行双边双线性过滤。</li><li>标记没有配备采样点的像素点</li></ol></li><li>修正 无法通过ray marching 操作从极线坐标中正确的插值的采样点</li><li>将散射图像拓展到源图像分辨率，并将其与衰减背景相结合<ol><li>执行双边过滤</li><li>标记没有配置采样点的像素点</li></ol></li><li>纠正散射</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;大气光散射（译文）&quot;&gt;&lt;a href=&quot;#大气光散射（译文）&quot; class=&quot;headerlink&quot; title=&quot;大气光散射（译文）&quot;&gt;&lt;/a&gt;大气光散射（译文）&lt;/h1&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;1-引言&quot;&gt;&lt;a href=&quot;#1-引言&quot; class=&quot;headerlink&quot; title=&quot;1. 引言&quot;&gt;&lt;/a&gt;1. 引言&lt;/h2&gt;&lt;p&gt;​    大气光散射是一种重要的自然现象，它是由光与传播介质中的粒子相互作用产生的。许多应用程序都需要用到这种效果，比如电脑游戏，为了提高场景的真实度，需要这种效果。为了精确计算散射分布，需要求解像素级的多重嵌套积分。由于涉及到算法的复杂度过高，因此在实时渲染中，实现大气散射是一个具有挑战性的难题。&lt;/p&gt;
&lt;p&gt;​    该文章介绍了一种利用极线采样来显著减少计算的光线行进的样本数量，的体积光渲染方法&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="图形" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%BD%A2/"/>
    
  </entry>
  
  <entry>
    <title>Unity傅里叶变换的应用——真实海平面模拟</title>
    <link href="http://yoursite.com/2018/10/16/Unity%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E7%9A%84%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E7%9C%9F%E5%AE%9E%E6%B5%B7%E5%B9%B3%E9%9D%A2%E6%A8%A1%E6%8B%9F/"/>
    <id>http://yoursite.com/2018/10/16/Unity%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E7%9A%84%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E7%9C%9F%E5%AE%9E%E6%B5%B7%E5%B9%B3%E9%9D%A2%E6%A8%A1%E6%8B%9F/</id>
    <published>2018-10-15T16:02:37.000Z</published>
    <updated>2020-11-08T15:40:31.650Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>傅里叶变换的定义描述，网上可以找到很多资源。而且讲得也很好懂。所以，在这篇文章中，不会大篇幅介绍傅里叶变换，假定了读者对傅里叶变换有了一定的了解。本篇的重点是，如何利用傅里叶变换的原理，在Unity游戏引擎中进行实际的应用。</p></blockquote><a id="more"></a><p>[TOC]</p><h2 id="傅里叶变换的算法"><a href="#傅里叶变换的算法" class="headerlink" title="傅里叶变换的算法"></a>傅里叶变换的算法</h2><p>就笔者而言，傅里叶变换的算法了解两种。一种是基本的遵循离散傅里叶公式，使用穷举计算所有元素的（DFT）。另一种是在遵循该公式的前提下，利用复数的性质，使用分治法进行迭代的快速傅里叶算法（FFT）。</p><h3 id="1-DFT方法"><a href="#1-DFT方法" class="headerlink" title="1. DFT方法"></a>1. DFT方法</h3><p>该方法没什么技巧可言。属于看到离散傅里叶公式，直接用代码描述的过程。</p><p>离散傅里叶公式如下：</p><script type="math/tex; mode=display">F(k)=\sum_{n=0}^{N}f(n)*e^{\frac{-j2\Pi nk}{N}}</script><p>依照公式可以写下如下的python的DFT代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> cmath <span class="keyword">import</span> exp,pi</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">ex=[<span class="number">1.0</span>,<span class="number">1.0</span>,<span class="number">1.0</span>,<span class="number">0</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dft</span><span class="params">(f)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    F=[]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    N=len(f)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(N):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        s=complex(<span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> range(N):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        s+=f[n]*exp(<span class="number">-2j</span>*pi*n*k/N)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        F.append(s)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> F</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">print(dft(ex))</span></pre></td></tr></table></figure><p>显而易见这是一个时间复杂度为O(n^2)的算法，在理解该方法后，能对傅里叶有更好的认识。</p><h3 id="2-FFT方法"><a href="#2-FFT方法" class="headerlink" title="2.FFT方法"></a>2.FFT方法</h3><p>该方法使用分治思想，能将复杂度降到O（nlogn）。FFT 算法分为两种</p><p>N为输入序列的长度</p><ul><li>对N等于2的整数次幂的算法<ul><li>基2算法</li><li>基4算法</li><li>……</li></ul></li><li>N不等于2的整数次幂的算法<ul><li>Winagrad算法</li><li>素因子算法</li><li>……</li></ul></li></ul><h4 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h4><h5 id="1-性质"><a href="#1-性质" class="headerlink" title="1. 性质"></a>1. 性质</h5><p>首先定义：</p><script type="math/tex; mode=display">W_{N}^{nk}=e^{\frac{-j2\Pi nk}{N}}</script><p>四个可用性质：</p><ul><li>周期性<script type="math/tex; mode=display">W_{N}^{nk}=W_{N}^{(N+n)k}=W_{N}^{n(N+k)}</script></li></ul><ul><li><p>对称性​    </p><script type="math/tex; mode=display">(W_{N}^{nk})^-(-代表共轭)=W_{N}^{-nk}=W_{N}^{(N-n)k}=W_{N}^{n(N-k)}</script></li><li><p>可约性</p><script type="math/tex; mode=display">W_{N}^{nk}=W_{mN}^{mnk}=W_{N/m}^{nk/m}</script></li><li><p>特殊点</p><script type="math/tex; mode=display">\begin{split}W_{N}^{0}&=1\\W_{N}^{N/2}&=-1\\W_{N}^{k+N/2}&=-W_{N}^{k}\end{split}</script></li></ul><p>四种性质的证明，不是太难，利用欧拉公式转换成三角函数就非常明了了。</p><p>首先欧拉公式如下：</p><script type="math/tex; mode=display">e^{jx}=\cos{x}+j\sin{x}</script><p>以周期性为例。</p><script type="math/tex; mode=display">W_{N}^{nk}=e^{\frac{-j2\Pi nk}{N}}=cos{(\frac{-nk}{N}2\Pi)}+sin(\frac{-nk}{N}2\Pi)</script><script type="math/tex; mode=display">\begin{align}W_{N}^{(N+n)k} & =  cos{(\frac{-nk-Nk}{N}2\Pi)}+jsin{(\frac{-nk-Nk}{N}2\Pi)}\\\\ &=cos(\frac{-nk}{N}2\Pi-k2\Pi)+jsin{(\frac{-nk}{N}}2\Pi-k2\Pi)\\\\ &=cos(\frac{-nk}{N}2\Pi)+jsin{(\frac{-nk}{N}2\Pi)}\\\\ &=W_{N}^{nk}\end{align}</script><p>其他性质证明大同小异，是来自三角函数的性质</p><h5 id="2-思路"><a href="#2-思路" class="headerlink" title="2.思路"></a>2.思路</h5><p> 利用上述性质，进行迭代，将DFT分解成更小的DFT计算，合并重复计算。</p><p> 算法有两条路线</p><ul><li>时间抽取</li><li>频率抽取</li></ul><p>按“基数”不同可以分成</p><ul><li>基-2FFT算法</li><li>基-4FFT算法</li><li>混合基算法</li><li>分裂基算法</li></ul><p>本篇描述是以时间抽取的基-2FFT算法，如果读者对其他算法感兴趣，可以在理解原理后，去查阅相关材料。</p><h5 id="3-算法步骤：时间抽取的基-2FFT"><a href="#3-算法步骤：时间抽取的基-2FFT" class="headerlink" title="3.算法步骤：时间抽取的基-2FFT"></a>3.算法步骤：时间抽取的基-2FFT</h5><ul><li><p>保证输入序列的长度为2的整数幂次。如4、128、512等，序列长度不满足时，补空项。</p></li><li><p>将输入序列按索引分成奇偶两组</p><script type="math/tex; mode=display">\begin{align}\\\\ 偶序列 f_1(i) &=f(2i)\\\\ 奇序列 f_2(i) &=f(2i+1)\\\\ i&=0,1...,\frac{N}{2}-1\end{align}</script></li><li><p>利用性质，进行分治迭代，一直分奇偶两组，直到序列项数为1(N=1)，无法再分。此时单项的傅里叶变换F(0)=f(n)。</p></li></ul><script type="math/tex; mode=display">\begin{align}F(k)&=\sum_{n=0}^{N-1}f(n)W_N^{nk}=\sum_{r=0}^{N/2-1}f(2r)W_N^{2rk}+\sum_{r=0}^{N/2-1}f(2r+1)W_N^{（2r+1）k}\\\\&=\sum_{r=0}^{N/2-1}f(2r)W_{N/2}^{rk}+W_N^k\sum_{r=0}^{N/2-1}f(2r+1)W_{N/2}^{rk}\\\\&=F_1(k)+W_N^kF_2(k)\end{align}</script><ul><li><p>到这一步，已经按照上述三个步骤。已经能写出代码了。示例 Python代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> cmath <span class="keyword">import</span> exp,pi</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> cmath <span class="keyword">import</span> log</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">ex=[<span class="number">1.0</span>,<span class="number">1.0</span>,<span class="number">1.0</span>,<span class="number">0</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fft</span><span class="params">(f,l)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    N=len(f)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> N&lt;=<span class="number">1</span>：</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> [f[<span class="number">0</span>] <span class="keyword">for</span> k <span class="keyword">in</span> range(l)]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    even=fft(f[<span class="number">0</span>::<span class="number">2</span>],l) <span class="comment">#偶数序列部分</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    odd=fft(f[<span class="number">1</span>::<span class="number">2</span>],l) <span class="comment">#奇数序列部分</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    T=[exp(<span class="number">-2j</span>*pi*k/N)*odd[k] <span class="keyword">for</span> k <span class="keyword">in</span> range(N)]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> [even[k]+T[k] <span class="keyword">for</span> k <span class="keyword">in</span> range(l)]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">print(fft(ex,<span class="number">4</span>))</span></pre></td></tr></table></figure></li><li><p>但是显而易见，如果仅仅只是这样并没有改变时间复杂度。依旧与穷举法一致，但通过观察，该算法可知道，其实这里面很多数值是重复的。比如当N=1时，需要返回l个f[0]。仅仅是为了占位。观察后，如果我们算法将重复的值只计算一次。那么复杂度将降到O(nlogn)</p></li><li><p>我们还需要一条性质——周期性：当N=1时，k=2时。依照周期性则F(2)=F(1)</p></li></ul><script type="math/tex; mode=display">  \begin{align}  例子：N&=4;k=7  \\\\F(7)&=F(7-4)=F(3)  \\\\=>F(N+l)&=F(l)  \\\\F(k)&=F_1(k)+W_N^kF_2(k)  \\\\k&=0,1,...,N-1(上述代码依此实现)  \\\\利用周期性，&k可以只取到N/2-1，也可以得到同样的结果  \\\\F(k)&=F_1(k)+W_N^kF_2(k)  \\\\W_N^{k+N/2}&=-W_N^k(化成三角函数，证明即可)  \\\\F(k+N/2)&=F_1(k)-W_N^kF_2(k)  \\\\k&=0,1,2...N/2-1  \end{align}</script><p>  ​    如此，每一层的分治，计算量将能够分成前半部，和后半部。而只要求出前半部，后半部也可以表示出来。这样就可以得到整个序列。且，时间复杂度降到了O(nlogn)</p><ul><li><p>该算法，因为其运算方式的流程图像，就像一只蝴蝶。所以又叫做蝶形运算。</p></li><li><p>该算法的Python代码例子如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> cmath <span class="keyword">import</span> exp,pi</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> cmath <span class="keyword">import</span> log</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">ex=[<span class="number">1.0</span>,<span class="number">1.0</span>,<span class="number">1.0</span>,<span class="number">0</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fft</span><span class="params">(f)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    N=len(f)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> N&lt;=<span class="number">1</span>：</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> f <span class="comment">#每次减去一半长度，到单一序列，长度正好为1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    even=fft(f[<span class="number">0</span>::<span class="number">2</span>]) <span class="comment">#偶数序列部分</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    odd=fft(f[<span class="number">1</span>::<span class="number">2</span>]) <span class="comment">#奇数序列部分</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    T=[exp(<span class="number">-2j</span>*pi*k/N)*odd[k] <span class="keyword">for</span> k <span class="keyword">in</span> range(N//<span class="number">2</span>)] <span class="comment">#只需要一半</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> [even[k]+T[k] <span class="keyword">for</span> k <span class="keyword">in</span> range(N//<span class="number">2</span>)]+[even[k]-T[k] <span class="keyword">for</span> k <span class="keyword">in</span> range(N//<span class="number">2</span>)]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">print(fft(ex))</span></pre></td></tr></table></figure></li></ul><h5 id="4-逆变换IFFT"><a href="#4-逆变换IFFT" class="headerlink" title="4.逆变换IFFT"></a>4.逆变换IFFT</h5><p>​    在计算出FFT后，推导IFFT就比较简单了。因为FFT和IFFT在计算公式上有很大的相似性</p><script type="math/tex; mode=display">\begin{align}& DFT: F(k)=\sum_{n=0}^{N-1}f(n)W_N^{nk}\\\\& IDFT:f(n)=\frac{1}{N}\sum_{k=0}^{N-1}F(k)W_N^{-nk}\end{align}</script><p>显而易见，逆变换与正变换，在运算上只有两点不同，一是系数1/N,二是旋转因子为共轭变换。</p><script type="math/tex; mode=display">\begin{align}&依照对称性，可知 W_N^{-nk}=(W_N^{nk})^{-}\\\\&复数乘法 已知 (A+Bi)●（C+Di)=(X+Yi)\\\\&那么如何得到（X-Yi)呢？即（X+Yi）的共轭\\\\&显而易见，依照复数乘法性质。即（A-Bi）和（C-Di）相乘即可。\\\\=>& f(n)=\frac{1}{N}\sum_{k=0}^{N-1}F(k)W_N^{-nk}\\\\=>& {f(n)}^-=\frac{1}{N}\sum_{k=0}^{N-1}{F(k)}^-W_N^{nk}\\\\=>& f(n)=\frac{1}{N}{\sum_{k=0}^{N-1}{fft(F(k)}^-)}^-\end{align}</script><p>如上所示。只需要在输入傅里叶序列进行一次共轭。再进行fft，结果乘上系数以及再次共轭。即可求出序列的逆变换。</p><p>示例Python代码如下。承接上述fft代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ifft</span><span class="params">(F)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    N=len(F)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    F=[k.conjugate() <span class="keyword">for</span> k <span class="keyword">in</span> F] <span class="comment">#对输入的傅里叶变换序列 进行共轭运算</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    F=fft(F) <span class="comment">#利用已经写好的fft函数进行运算</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    F=[(k.conjugate())/N <span class="keyword">for</span> k <span class="keyword">in</span> F] <span class="comment">#得到结果</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> F</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">F=fft(ex)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">print(F)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">print(ifft(F))</span></pre></td></tr></table></figure><h2 id="Unity的傅里叶变换实现"><a href="#Unity的傅里叶变换实现" class="headerlink" title="Unity的傅里叶变换实现"></a>Unity的傅里叶变换实现</h2><blockquote><p>到这一步，快速傅里叶的算法思路，就已经介绍完了。接下来就是，将这套算法移植到Unity中。使用GPU编程，对图像进行傅里叶变换。</p></blockquote><h4 id="ComputeShader"><a href="#ComputeShader" class="headerlink" title="ComputeShader"></a>ComputeShader</h4><p>本篇的傅里叶实现，核心是使用ComputeShader，进行实时的傅里叶变换。CPU的傅里叶实现，基本上与Python的实现差不多，只需要将python的例子，移植到C#语言上就没有问题了。但是实时的话，还是利用GPU来运算效率会更高。</p><p>Unity的ComputeShader的基本使用，在本篇文章中假定了读者对其有了一定了解，不再做详细的介绍。不熟悉的读者可查阅相关关键词。</p><p>ComputeShader本身语法与Shader区别不大。不过ComputeShader比起Shader，设计上主要是针对并行计算。</p><h5 id="CS的关键性质"><a href="#CS的关键性质" class="headerlink" title="CS的关键性质"></a>CS的关键性质</h5><ul><li>CS的代码执行，首先分线程组。C#中对应API为ComputeShader.Dispatch(int i,int x,int y, int z)。x,y,z可由调用者，自行分配。</li><li>每一组中可并行执行多个线程，在CS里使用[numthread(x,y,z)]来分配线程组中的线程数。</li><li>在同一个线程组中的线程，可以抽象的认为是并行的，所以线程的调用顺序是不可知的，即6号线程可能先执行再执行1号线程。在Unity中可定义的线程数的极限是1024个</li><li>同一个线程组有办法做到共享内存，内存大小为32KB</li><li>函数中可以调用线程等待函数，即线程运行到等待函数后，被挂起，在同一个线程组中的线程都运行到该处后，才能继续执行下去</li></ul><p>这五点，对于ComputeShader特别关键。本篇介绍得比较粗糙，如果读者不懂，必须要查阅资料弄明白，才能理解接下来的示例。</p><h5 id="二维傅里叶变换"><a href="#二维傅里叶变换" class="headerlink" title="二维傅里叶变换"></a>二维傅里叶变换</h5><blockquote><p>未完，待更！</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;傅里叶变换的定义描述，网上可以找到很多资源。而且讲得也很好懂。所以，在这篇文章中，不会大篇幅介绍傅里叶变换，假定了读者对傅里叶变换有了一定的了解。本篇的重点是，如何利用傅里叶变换的原理，在Unity游戏引擎中进行实际的应用。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="algorithm" scheme="http://yoursite.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>刚开始的一些话</title>
    <link href="http://yoursite.com/2018/10/08/%E5%88%9A%E5%BC%80%E5%A7%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AF%9D/"/>
    <id>http://yoursite.com/2018/10/08/%E5%88%9A%E5%BC%80%E5%A7%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AF%9D/</id>
    <published>2018-10-08T08:59:42.000Z</published>
    <updated>2020-11-08T15:40:31.652Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是放到github page 写的第一篇文章。本来在csdn写的文章，想了想，没写几篇，而且现在觉得写得并不好，就不在想搬过来了。所以这也就是一个新的开始了。我这篇文字，就想描述我要写的一些文章方向，当然现在还没写，就当做是目标，或者说目录吧。</p></blockquote><h2 id="TAGs"><a href="#TAGs" class="headerlink" title="TAGs"></a>TAGs</h2><ul><li><p>Unity的游戏开发</p></li><li><p>游戏渲染（图形学）</p></li><li>人工智能</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;这是放到github page 写的第一篇文章。本来在csdn写的文章，想了想，没写几篇，而且现在觉得写得并不好，就不在想搬过来了。所以这也就是一个新的开始了。我这篇文字，就想描述我要写的一些文章方向，当然现在还没写，就当做是目标，或者说目录吧。&lt;
      
    
    </summary>
    
    
    
      <category term="log" scheme="http://yoursite.com/tags/log/"/>
    
  </entry>
  
</feed>
